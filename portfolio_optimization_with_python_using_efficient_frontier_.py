# -*- coding: utf-8 -*-
"""Portfolio Optimization with Python using Efficient Frontier .ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1AGFrVVpidUytAAh0fvEz_0H2MZSQAZi0
"""

# Import necessary libraries
import numpy as np
import pandas as pd
import yfinance as yf  # Use yfinance instead of pandas_datareader
import matplotlib.pyplot as plt

# 1. Download stock data for Apple, Nike, Google, and Amazon for 10 years
symbols = ['AAPL', 'NKE', 'GOOGL', 'AMZN']
# Use yf.download to get data
df = yf.download(symbols, start='2014-01-01', end='2024-12-31')

# Keep only the Adjusted Close prices
# yfinance with auto_adjust=True puts adjusted close in 'Close'
df = df['Close']

# 2. Calculate daily log returns
log_returns = df.pct_change().apply(lambda x: np.log(1 + x))

# 3. Calculate covariance matrix of log returns
cov_matrix = log_returns.cov()

# 4. Calculate expected annual returns (mean of yearly returns)
# Resample to yearly prices, then calculate yearly returns, then mean
yearly_prices = df.resample('Y').last()
yearly_returns = yearly_prices.pct_change()
ind_er = yearly_returns.mean()

# 5. Calculate annualized volatility (standard deviation of daily log returns scaled by sqrt(250))
ann_sd = log_returns.std() * np.sqrt(250)

# Show individual asset expected returns and volatilities
assets = pd.concat([ind_er, ann_sd], axis=1)
assets.columns = ['Returns', 'Volatility']
print("Individual asset returns and volatilities:")
print(assets)

# 6. Monte Carlo simulation to generate random portfolios

num_assets = len(symbols)
num_portfolios = 10000

p_ret = []      # Portfolio returns
p_vol = []      # Portfolio volatility
p_weights = []  # Portfolio weights

for _ in range(num_portfolios):
    weights = np.random.random(num_assets)
    weights /= np.sum(weights)  # Normalize weights to sum to 1
    p_weights.append(weights)

    # Expected portfolio return
    returns = np.dot(weights, ind_er)
    p_ret.append(returns)

    # Portfolio variance
    var = cov_matrix.mul(weights, axis=0).mul(weights, axis=1).sum().sum()
    sd = np.sqrt(var)  # daily std dev

    # Annualize volatility
    ann_vol = sd * np.sqrt(250)
    p_vol.append(ann_vol)

# Create DataFrame of portfolio metrics
data = {
    'Returns': p_ret,
    'Volatility': p_vol,
}
for i, symbol in enumerate(symbols):
    data[f'{symbol} Weight'] = [w[i] for w in p_weights]

portfolios = pd.DataFrame(data)

# 7. Plot the Efficient Frontier
plt.figure(figsize=(10, 10))
plt.scatter(portfolios['Volatility'], portfolios['Returns'], c='blue', marker='o', s=10, alpha=0.3)
plt.xlabel('Volatility (Annualized Standard Deviation)')
plt.ylabel('Expected Returns (Annual)')
plt.title('Efficient Frontier')
plt.grid(True)

# 8. Find the minimum volatility portfolio
min_vol_port = portfolios.iloc[portfolios['Volatility'].idxmin()]

# Plot minimum volatility portfolio
plt.scatter(min_vol_port['Volatility'], min_vol_port['Returns'], color='red', marker='*', s=500, label='Min Volatility')

# 9. Calculate Sharpe Ratio and find optimal risky portfolio
rf = 0.01  # risk-free rate
portfolios['Sharpe Ratio'] = (portfolios['Returns'] - rf) / portfolios['Volatility']
optimal_risky_port = portfolios.iloc[portfolios['Sharpe Ratio'].idxmax()]

# Plot optimal risky portfolio
plt.scatter(optimal_risky_port['Volatility'], optimal_risky_port['Returns'], color='green', marker='*', s=500, label='Optimal Risky Portfolio')

plt.legend()
plt.show()

# 10. Print details of optimal portfolios
print("\nMinimum Volatility Portfolio:")
print(min_vol_port)

print("\nOptimal Risky Portfolio (Max Sharpe Ratio):")
print(optimal_risky_port)